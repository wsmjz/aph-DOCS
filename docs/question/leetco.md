# 题目

- 1
```js
var o = {
    a: 10,
    b: {
        fn: function() {
            console.log(this.a)  // undefind
        }
    }
}
o.b.fn()
```
```js
var o = {
    a: 10,
    b: function() {
            console.log(this.a)  // 10
        }
}
o.b()
```
```js
a = 1
var o = {
    a: 10,
    b: function() {
            console.log(this.a)  // 10
        }
}
o.b()
```
```js
var o = {
    a: 10,
    b: function() {
            console.log(a)  // ReferenceError: a is not defined
        }
}
o.b()
```
```js
a = 1
var o = {
    a: 10,
    b: function() {
            console.log(a)  // 1
        }
}
o.b()
```
- 作用域
```js
x = 1;
var obj = {
    x: 2,
    dbl: function () {
        // this.x *= 2;
        // x *= 2;
        console.log(x);
        // console.log(this.x);
    }
};
// 说出下面的输出结果
obj.dbl();
//解析：this.x指向当前对象，所以this.x *= 2等同于obj.x *= 2
//而x *= 2，在当前作用域中没有找到声明，则在全局作用域下查找是否有x, x *= 2等同于window.x *= 2
//日志打印输出2 4，此时window.x为2, obj.x为4

var func = obj.dbl;
func();
//func()没有前缀，所以func()相当于window.func()，此时func()中的x与this.x均指向window.x
//日志打印输出8 8，此时window.x为8, obj.x为4


var funcBind = obj.dbl.bind(obj);
funcBind();
//func()没有前缀，但是因为通过bind()方法，把funcBind()的作用域与obj的作用域绑定起来，所以func()相当于obj.dbl()，其中x作用域与上面👆一样查找x，只不过此时window.x为8, obj.x为4
//日志打印输出16 8
```
> 函数在被直接调用的时候，其中的this指针永远指向window
> 匿名函数 this总是指向window对象
> 谁执行函数，this就指向谁
> 如果函数new了一下，那么就会创建一个对象，并且this指向新创建的
- new URLSearchParams() 与 new FormData()区别
# http
## 状态码
- 服务端 缓存
## post get cooki 更高
## 握手协议
- 为什么要3次握手
- 因为HTTP是一个基于TCP的协议,而TCP是一种可靠的传输层协议.
- 3次握手，4次挥手是针对TCP连接来说的，HTTP协议本身不关注这块
- [链接](https://www.zhihu.com/question/67772889)
- 如果要考察HTTP,我觉得问下HTTP请求/响应报文的组成可能会更好.HTTP请求报文组成:请求行+请求头+请求体HTTP响应报文组成:响应行+响应头+响应体请求行: 请求方法(HEAD/GET/POST) + 请求URL + HTTP协议版本响应行: HTTP协议版本 + 状态码 + 状态码描述请求头: 比如客户端的Cookie和User-Agent就放在这里.响应头: 比如服务器的Set-Cookie和Server信息就放在这里.请求体: 比如客户端POST的数据就放在这里(对比:GET的数据放在请求行的URL里).响应体: 比如服务器返回的HTML和JSON数据就放在这里.。
## 请求流程
> dns 查询, 解析（过程） => tcp连接 => 发送Http请求 => 服务器处理请求返回HTTP报文 => 浏览器解析渲染页面(请求数据接口) => 连接结束
## 浏览器
- 渲染原理
- 允许跨域会出现什么问题
   - 跨域的访问会带来许多安全性的问题，比如，cookie一般用于状态控制，常用于存储登录的信息，如果允许跨域访问，那么别的网站只需要一段脚本就可以获取你的cookie，从而冒充你的身份去登录网站，造成非常大的安全问题，因此，现代浏览器均推行同源策略。
- 浏览器缓存机制
[]
   - 预请求
   - 协议缓存
- 垃圾回收机制内部实现
## 数据请求方法
- get
- post
- 其他方法 detele
> get 和 post 的不同
## axios 中有两个请求不用 请求拦截 如何做
## webhooks => nglix => docker
## 算法
- 'afgdfddd' 找出字符串中出现次数最多的元素
## npm 脚本传参 -- --config webpack.dev.js

## 面试点
- 法则
- uniApp
- node.js / moogDB
- react / ts
- SSR nuxt / next
- webApp
- promise Es6
- MVVM router vuex
   - 响应式数据 数据劫持
- webpack 优化
- js基础Api 设计模式
   - 防抖，节流
   - 事件环
   - 执行栈，上下
- diff 算法 持续n集成
- 云开发
- webGle
- 单元测试
## 面试问题
- sort 默认按什么规则排序
- webpack是如何实现前端模块化的
- 我给同学们规划的简历项目亮点
1. 给公司使用node+mysql+kafka+nignx搭建了前端监控系统，把发现异步错误的时间缩短为原来的5分之1，通过监控性能指标，持续进行全链路调优，首屏加载时间从2.4秒缩短为0.8秒，BUG的修复速度提升为原来的3倍。
2. 给合部门多个项目的共性需求，编写了最适合部门业务的高复用可配置的组件库，并在公司得到了大面积推广，让公司的项目开发效率提升了30%
3. 为了加快项目构建速度，开发并推广了公司内部的脚手架CLI，减少了项目创建的重复劳动和重复配置，创建新项目时间只有原来的10分之1
4.搭建持续集成流程，开发测试可以同步进行，编写代码之后可以自动进行构建布署和联调，使回归测试的时间减少50%，提测的 bug率减少40%
5. 因为项目类型较多，技术栈也不统一，所以参考乾坤开发了公司的微前端框架，并成功落地,成功集成了公司的react和vue不同技术栈的产品,节约了数千万的重构开发经费.
- 无论是大厂还是小厂，前端架构师都是有别于普通前端开发的一个高级职位。很多人误以为只要在一线开发岗位做个两到三年，就可以自然而然晋升了。但现实往往会打你的脸，很多人工作五年以上想找个架构师的岗位却依然连面试的机会都没有。
这主要在于你没有正确认清前端架构师的岗位职责。
作为一个普通开发，你主要的任务是完成上级交代的业务项目。你需要和产品撕逼，你需要加班赶进度，你需要熬夜发布。你会有种种的工作上的不开心，而作为架构师，你的唯一任务就是：帮助组内其它成员解决这些让他不开心的问题。
公司是靠业务盈利的，公司更不可能花大价钱养一个对业务没有帮助的闲人。架构师不是不做业务，而是通过间接的方式提高业务产出效率。

1. 技术选型
目前前端业内 React/Vue/Angular 三大框架鼎立，架构师需要负责挑选合适的框架来应付不同的业务。很多前端认为：“这还需要挑吗？我之前一直用 Vue 的，其它我也不会啊。”请记住你们是一个团队在奋斗，假如团队多数成员都有多年Angular经验，执意改成其它框架是不可取的。技术选型时，需要兼顾团队人员、现有项目和改造风险的。你可以主导推荐某个技术，但最终必须由全员投票决定最终的选择。

2. 开发规范
开发规范包括：编码规范、分支规范、发布流程规范等影响开发整个流程的所有规范制度。制定规范很简单，但你的工作职责不能只是制定，而更应该负责提供确保规范可以落地的有效解决方案和配套工具，否则你的规范只是一纸空文。

3. 组件库
很大一部分架构师都在负责开发组件库，没错，组件库开发可能占据了你大部分工作时间。架构之所以在技术上比普通开发牛，主要也体现在普通开发只能针对他当前的业务完成逻辑，而架构师可以将业务抽象为组件，批量地完成类似的需求。

4. 开发工具
人类和动物的最大差别在于人类能够利用各种工具。任何开发效率的提升都需要工具的支持。架构师需要为团队找到最好用的工具，帮助团队提高效率。

5. 攻克难题
多数的开发任务不难，所有人都可以解决，只是效率上的差异。但还是有一些问题，是多数人解决不了的，这时，作为一个架构师——团队内技术水平最高的人一定要能及时出面解决这些问题。

6. 团队提升
作为架构师，你往往比其他人具有更多的项目经验和能力，你也是团队内其他人学习的榜样。但你也需要帮助其它成员成长，比如在代码评审环节指出问题、开展定期分享培训、整理开发文档。

7. 挖掘技术潜力
技术的发展非常快，特别是前端领域，几年换个框架。你需要时刻保持新兴技术的敏感度，思考新技术是否对公司有帮助，并尝试让新技术落地开花。

在明确了架构师的职责后，如果你今后想成为一名大厂的架构师，就应该有了明确的学习方向。上面这些事情，哪些是你目前还做不到的，你就应该专项练习。
- 现代前端开发框架 vue/ng/react 主要解决了这几类问题

1. 封装了数据向dom视图的抽象，也就是说我们拿着api，导入结构化数据，就很轻松渲染出dom视图，再也不用自 己写dom增删改查的api。
2. 保证重绘时，第一是最小集的dom更新，因浏览器渲染机制总结出的优化方案；
3. 引用操作系统调度算法的时间片时机，在保证浏览器正常渲染元素的基础之上利用空闲资源压榨将浏览器渲染性能；（fiber）
4. 解决前端开发工程化的问题；

- 做为一个工程师来讲，无论是前端开发还是后端开发。是需要掌握四类语言的，每类语言至少需要掌握一门。其中C语言是一定需要掌握的，其次面向过程类语言c++ Java go至少要掌握一个。对于前端来说，面向对象类语言掌握C++的性价比最高。然后脚本类语言shell python至少掌握一样。再然后就是工作中使用的语言，前端就是JavaScript和typescript。有余力最好再掌握一门函数式语言。最小集至少也得掌握C/C++，js/ts，shell。维持工作使用。当然这里面C++相对比较难，学习c++
## 工作体会
- 刻意练习核心原理
- 勿说精通，应说熟悉掌握
## 知识体系
![](./tixi1.png)
![](./tixi2.png)
![](./tixi3.png)
